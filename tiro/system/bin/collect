#! /usr/bin/perl
use warnings; # Full warnings
use strict; # Strict error checking
$|++; # Unbuffer stdout
umask 0077; # Default to private files
delete @ENV{qw(PATH IFS CDPATH ENV BASH_ENV)}; # Make %ENV safer

# Configuration
use constant CONFIG_FILE => 'system/config.cfg';
use lib 'system/lib';

use Tiro;
use File::Copy qw(copy); # NOTE: move() has tainting issues
use Getopt::Long qw(:config auto_version auto_help);
use File::Spec::Functions;

$main::VERSION=1.0;
my ($BEFORE, $AFTER, @USERS, @ASSIGNMENTS, $FAILED, $VERBOSE);
my $GROUP=1;

GetOptions('before=s' => \$BEFORE, #default late-after
           'after=s' => \$AFTER, # default none
           'user=s@' => \@USERS, # default all users
#           'assignment=s@' => \@ASSIGNMENTS,
           'failed!' => \$FAILED, # failed
           'group!' => \$GROUP,
           'verbose!', \$VERBOSE);

my ($ASSIGNMENT, $DEST) = @ARGV;

my $tiro = Tiro->new(CONFIG_FILE);
print "AS: $ASSIGNMENT T:$tiro\n";
my $assignment = $tiro->assignment($ASSIGNMENT);
my @users = @USERS ? map {$tiro->users->{$_}} @USERS : values %{$tiro->users};

# TODO: true late_after
$BEFORE = defined $BEFORE ? $BEFORE :
  $assignment->late_after ne '' ? $assignment->late_after : $assignment->due;
#$AFTER = date($AFTER) if $AFTER;
#$BEFORE = date($BEFORE) if $BEFORE;

print "A:$AFTER B:$BEFORE\n";


#exit 1;

my @subs;
for my $user (@users) {
  my @dates = $assignment->submissions($user, $GROUP);
  #@dates = grep {$BEFORE le $_->date} @dates if $BEFORE ne '';
  #@dates = grep {$AFTER ge $_->date} @dates if $AFTER ne '';
  @dates = grep {not $_->failed} @dates if not $FAILED;
  @dates = $dates[$#dates] if @dates;
  push @subs, @dates;
}

for (uniq_submissions(@subs)) {
  system("cp", "--recursive", "--interactive", "--parents",
         catfile($tiro->submissions_dir, $_->user->id, $_->date . $_->failed),
         catfile($DEST, join('-', map {$_->id} @{$_->group})));
  print($? ? "FAILED" : "ok\n");
}

#cp -r $_->folder, $dates[0]->group->id;

=end

for $user ($assignment->dir) {
  my ($latest) = sort {$b cmp $a}
  grep { not $_->failed }
  grep { $_ le $LATEST } ($assignment->user->date);

  if (defined $latest) {
    copy -r $latest $user
  }
}


my $tiro;

my $assignment(path);

for ($assignment->submissions(user, 1)) {
      @dates = grep {start_date() le $_->date} @dates if start_date();
      @dates = grep {end_date() ge $_->date} @dates if end_date();
      @dates = grep {not $_->failed} @dates if not show_failed();
      @dates = ($dates[$#dates]) if $#dates != -1 and only_latest();    
      push;
}

uniq

cp -r $_->folder, $dates[0]->group->id;

users = ...

  list_assignments(id) {
    subs {
      
    }
}



--after
--before (late-after)

--flatten
--section

--dos2unix
--user
--verbose

--process [file] ???
--latest ???

Usage: vcollect [ - adflprsuv ] [assignment-name] [destination-subdirectory]

  +a [YYYY,MM,DD,HH:MM:SS] collect files submitted after the given date
  ?d [YYYY,MM,DD,HH:MM:SS] use the given due date instead of Vincents
  *f (flatten) collect only the single latest file renaming as username
  +l collect the latest submissions ignoring any due date
  ?p [file] process files after copying
  +r assume all files are ascii text and reformat them as Unix files
  +s organize submissions by section number
  +u [user-name] copy only files for the given user name
  +v  print information on each file copied.
